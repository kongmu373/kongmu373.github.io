<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on kongmu373的博客</title>
    <link>https://kongmu373.github.io/posts/</link>
    <description>Recent content in Posts on kongmu373的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 13 Jun 2020 14:03:41 +0800</lastBuildDate>
    
	<atom:link href="https://kongmu373.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Html常用标签</title>
      <link>https://kongmu373.github.io/posts/html/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Sat, 13 Jun 2020 14:03:41 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/html/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</guid>
      <description>a 标签 a标签的两个属性： href (hyper ref 超引用或者超链接) 可以选择的取值 网址(跳转到别人的页面上) https://google.com http://google.com //google.com (继承当前的协议) 路径(在自己http服务进行跳转) /a/b/c 以及 a/b/c 开启http服务之后，(&amp;quot;/&amp;quot;)根目录就不再是硬盘的根目录 (&amp;quot;/&amp;quot;)根目录的位置在于你</description>
    </item>
    
    <item>
      <title>Item7</title>
      <link>https://kongmu373.github.io/posts/effective-java/item7/</link>
      <pubDate>Fri, 12 Jun 2020 19:30:16 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/effective-java/item7/</guid>
      <description>Item7: Eliminate obsolete object references （排除过时的对象引用） 自实现的栈可能存在忽略的内存泄露 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 mport java.util.Arrays; import java.util.EmptyStackException; // Can you spot the &amp;#34;memory leak&amp;#34;? public class Stack { private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(Object e) { ensureCapacity(); elements[size++] = e; } public Object pop() { if (size == 0) throw new EmptyStackException(); return elements[--size]; } /** * Ensure space for at least one more element, roughly * doubling</description>
    </item>
    
    <item>
      <title>Item6</title>
      <link>https://kongmu373.github.io/posts/effective-java/item6/</link>
      <pubDate>Fri, 12 Jun 2020 16:27:48 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/effective-java/item6/</guid>
      <description>Item6 Avoid creating unecessary objects(避免创建不必要的对象) 重用对象从而提高性能 exmaple1: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // Reusing expensive object for improved performance (Pages 22 and 23) public class RomanNumerals { // Performance can be greatly improved! (Page 22) static boolean isRomanNumeralSlow(String s) { return s.matches(&amp;#34;^(?=.)M*(C[MD]|D?C{0,3})&amp;#34; + &amp;#34;(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$&amp;#34;); } // Reusing expensive object for improved performance (Page 23) private static final Pattern ROMAN = Pattern.compile( &amp;#34;^(?=.)M*(C[MD]|D?C{0,3})&amp;#34; + &amp;#34;(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$&amp;#34;); static boolean isRomanNumeralFast(String s) { return ROMAN.matcher(s).matches(); } public static void main(String[] args) { int numSets = Integer.parseInt(args[0]);</description>
    </item>
    
    <item>
      <title>Item4 5</title>
      <link>https://kongmu373.github.io/posts/effective-java/item4-5/</link>
      <pubDate>Fri, 12 Jun 2020 16:01:33 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/effective-java/item4-5/</guid>
      <description>Item4 Enforce noninstantiability with a private constructor(强迫非实例化的类使用私有构造方法) 1 2 3 4 5 6 7 8 9 // Noninstantiable utility class public class UtilityClass { // Suppress(禁用) default constructor for noninstantiability. private UtilityClass() { throw new AssertionError(); } // Remainder omitted } 总结 使用私有构造方法避免实例化该类 如果调用该私有方法就抛出异常 这种技术在构建工具类的时候，经常会被用到 Item5 Prefer dependency injection to hardwiring resources (依</description>
    </item>
    
    <item>
      <title>Spring</title>
      <link>https://kongmu373.github.io/posts/Spring/</link>
      <pubDate>Fri, 12 Jun 2020 08:57:48 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/Spring/</guid>
      <description>Spring是什么? Java世界应用的事实标准 Spring容器 - 一个 IoC容器 Spring MVC - 基于Spring和Servlet的Web应用框架 Spring Boot - 集成度和自动化程序更高 没有Spring,我们会怎么做呢? 选择一: 一个main程序打天下 非常轻量，适用于非常简单的场景 一旦规模上来之后 难以维护 是</description>
    </item>
    
    <item>
      <title>Mybatis</title>
      <link>https://kongmu373.github.io/posts/java/Mybatis/</link>
      <pubDate>Thu, 11 Jun 2020 11:15:28 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/java/Mybatis/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Java的注解</title>
      <link>https://kongmu373.github.io/posts/java/Java%E7%9A%84%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Wed, 10 Jun 2020 16:21:49 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/java/Java%E7%9A%84%E6%B3%A8%E8%A7%A3/</guid>
      <description>什么是注解? Class是什么？ Class是Java类的说明书 你或者JVM阅读该说明书，创建类的实例 注解就是说明书中的一小段信息/文本/标记 Annotation 可以携带参数 可以在运行时被阅读 注解怎么写? 新建一个类选择注解 元注解 @Rentention 保留,RetentionPolicy 默认CLASS 2 @Target ElementType @Documented @Inherited @Repeatable 注解的属性</description>
    </item>
    
    <item>
      <title>Item3</title>
      <link>https://kongmu373.github.io/posts/effective-java/item3/</link>
      <pubDate>Wed, 10 Jun 2020 16:16:08 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/effective-java/item3/</guid>
      <description>Item 3:Enforce the singleton property with a private consturctor or an enum type 使用私有构造函数或枚举类型实施单例属性 Singleton with public final field (使用final字段实现单例) 不好使用单元测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Elvis { public static final Elvis INSTANCE = new Elvis(); private Elvis() {} public void leaveTheBuiding() { // do something } // This code would normally appear outside the class! public static void main(String[] args) { Elvis elvis = Elvis.INSTANCE; elvis.leaveTheBuilding(); } } Single with static factory 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16</description>
    </item>
    
    <item>
      <title>Item2</title>
      <link>https://kongmu373.github.io/posts/effective-java/item2/</link>
      <pubDate>Wed, 10 Jun 2020 15:45:39 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/effective-java/item2/</guid>
      <description>Item 2: Consider a builder when faced with many constructor parameters. 都构造函数有多个参数时，考虑用builder. 当类的参数过多的时候,使用不同方法创建对s象对应的情况 构造函数 过于啰嗦 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // Telescoping constructor pattern - does not scale well! public class NutritionFacts { private final int servingSize; // (mL) required private final int servings; // (per container) required private final int calories; // (per serving) optional private</description>
    </item>
    
    <item>
      <title>Item1</title>
      <link>https://kongmu373.github.io/posts/effective-java/item1/</link>
      <pubDate>Wed, 10 Jun 2020 15:42:17 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/effective-java/item1/</guid>
      <description>Item1: 考虑以静态工厂方法代替构造函数 什么是静态工厂方法 它是一个类提供的公共静态工厂方法，作用只是一个返回类实例的静态方法。 例子 1 2 3 4 // boolean 基本类型 转换为 Boolean 对象的引用 public static Boolean valueOf(boolean b) { return b ? Boolean.TRUE : Boolean.FALSE; } 注意的是静态工厂方法与来设计模式的工厂方法模式不同. 静态工厂方法的优缺点 相较于构造函数的优点:</description>
    </item>
    
    <item>
      <title>Java的泛型</title>
      <link>https://kongmu373.github.io/posts/Java%E7%9A%84%E6%B3%9B%E5%9E%8B/</link>
      <pubDate>Tue, 09 Jun 2020 18:53:43 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/Java%E7%9A%84%E6%B3%9B%E5%9E%8B/</guid>
      <description>为什么需要泛型? 其实, 以前是没有泛型的 没有泛型写起来就很啰嗦,不同的类型要写出很多除了类型都相同的代码 有了泛型就可以用省力的方法编写类型安全的代码 List&amp;lt;String&amp;gt; Map&amp;lt;String, Object&amp;gt; Map&amp;lt;String, List&amp;lt;Object&amp;gt;&amp;gt; 泛型存在的问题 向后兼容性 https://www.zhihu.com/question/28665443 只有两条路: type erasue(擦除) -&amp;gt; Java的选择 搞一套全新的API -&amp;gt; C#的选择 Java选择擦除带</description>
    </item>
    
    <item>
      <title>类型与反射</title>
      <link>https://kongmu373.github.io/posts/%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Tue, 09 Jun 2020 11:19:47 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%8D%E5%B0%84/</guid>
      <description>Spring全家桶，任何上规模的框架,都使用了框架 Java的类与Class RTTI(Run-Time Type Identification) 运行时类型识别 将子类赋值给父类,调用子类的方法报错 1 2 Object obj = new WhiteCat(); obj.catchMouse(); // catchMouse()是猫的方法，Object类没有这个方法，所以编译报错 Object.getClass 实体方法拿到类型信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17</description>
    </item>
    
    <item>
      <title>字符串原理</title>
      <link>https://kongmu373.github.io/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 08 Jun 2020 16:57:36 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%9F%E7%90%86/</guid>
      <description>字符串是最重要的引用类型 互联网基本上只干一件事: 处理字符串 能处理好字符串是Web服务器的基本要求 字符串的不可变性 字符串的不可变是如何保证的? String是final class不能被继承 保存字符的数组是final的，不能改变指向 String的所有公开API都不能改变这个value的</description>
    </item>
    
    <item>
      <title>HashMap源码分析</title>
      <link>https://kongmu373.github.io/posts/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 08 Jun 2020 10:09:46 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>常见面试问题 HashMap默认容量? HashMap如何扩容? HashMap的数组大小为什么一定要是2的幂? HashMap为什么是线程不安全的 Java 7到8做了哪些改进? 为什么? &amp;hellip; 哈希表的简介 核心是基于哈希值的桶和链表 将一个元素映射成一个便于搜索的哈希值 O(1)的平均查找,插入 删除时间 桶</description>
    </item>
    
    <item>
      <title>基础算法与数据结构</title>
      <link>https://kongmu373.github.io/posts/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 08 Jun 2020 08:14:31 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>程序=算法+数据结构 (程序如何执行 + 怎么存储数据) 为什么我们需要算法和数据结构呢？ 计算机世界的基石， 是程序员的内功 对代码效率的提升是本质的 面试需要&amp;hellip; 算法的复杂度 时间复杂度 O(1) - 哈希桶/数组随机寻址 (常数) 和问题的规模无关 O(n) - 遍历 (线性) 在数组中找某个元素 解决问题的时间</description>
    </item>
    
    <item>
      <title>Stream</title>
      <link>https://kongmu373.github.io/posts/stream/</link>
      <pubDate>Sun, 07 Jun 2020 14:33:15 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/stream/</guid>
      <description>什么是Stream 一个 &amp;ldquo;流&amp;rdquo; 好处: 不容易出错 简化代码 可读性/可维护性++ // 请把姓张的用户挑出来，把他们按照年龄排序,然后把它们的名单报告给我 List&amp;lt;User&amp;gt; users = getUsers(); List&amp;lt;String&amp;gt; list = users.stream(). filter(user -&amp;gt; user.name.startsWith(&amp;quot;张&amp;quot;)) .sorted((Comparator.comparing(User::getAge))) .map(User::getName) .collect(Collectors.toList()); 使用idea的pl</description>
    </item>
    
    <item>
      <title>进阶算法</title>
      <link>https://kongmu373.github.io/posts/%E6%A1%B6%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Tue, 02 Jun 2020 20:33:41 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E6%A1%B6%E6%8E%92%E5%BA%8F/</guid>
      <description>面试算法题套路 沟通和交流 得到算法题 沟通理解题意 给出暴力解(不动脑子的解法) 分析问题，沟通 给出正常的算法解题 优化(剪枝) 动态规划 找出状态转移方程 上台阶问题 有一楼梯共m级，若每次只能跨上一级或二级，要走上第m级,共有多少走法? f(m) = f(m-1) + f(m-2) 硬币问题</description>
    </item>
    
    <item>
      <title>线程池</title>
      <link>https://kongmu373.github.io/posts/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link>
      <pubDate>Tue, 02 Jun 2020 08:28:19 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid>
      <description>线程池与Callable/Future 什么是线程池 线程时昂贵的 (Java线程模型的缺陷) 线程池时预先定义好的若干个线程 Java中的线程池 不用频繁创建线程 Callable/Future 类比Runnable, Callable可以返回值，抛出异常 Future代表一个&amp;quot;未来才会返回的结果&amp;rdquo; 实战</description>
    </item>
    
    <item>
      <title>生产者与消费者模型</title>
      <link>https://kongmu373.github.io/posts/%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jun 2020 19:09:43 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</guid>
      <description>使用三种方法解决生产者与消费者模型 wait/notify/notifyAll Lock/Condition(JUC) BlockingQueue(JUC) wait/notify/notifyAll 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 public class Main { public static void main(String[] args) throws InterruptedException { final Object lock = new Object(); Optional&amp;lt;Integer&amp;gt; empty = Optional.empty(); Container container = new Container(empty); Producer producer = new Producer(container, lock); Consumer consumer = new Consumer(container, lock);</description>
    </item>
    
    <item>
      <title>多线程带来的问题</title>
      <link>https://kongmu373.github.io/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 01 Jun 2020 13:41:41 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>线程不安全的表现 数据错误 i++问题 死锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // 死锁代码 public class Main { private static final Object lock1 = new Object(); private static final Object lock2 = new Object(); public static void main(String[] args) throws InterruptedException { new Thread1().start(); new Thread2().start(); } private static class Thread1 extends Thread { @Override public void run() { synchronized (lock1) { try { Thread.sleep(500); } catch (InterruptedException ignored) { } synchronized (lock2) { System.out.println(); } } } } private static class Thread2 extends</description>
    </item>
    
    <item>
      <title>多线程基本原理</title>
      <link>https://kongmu373.github.io/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jun 2020 10:41:18 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description>为什么需要多线程? Thread线程 Java中线程的表示 多线程问题的来源 多线程的应用场景 一、为什么需要多线程? Java的执行模型是同步/阻塞的 如果你执行非常耗时的操作，当前方法的执行流会阻塞，等待耗时的操作执行完 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // main方法要打印&amp;#34;main&amp;#</description>
    </item>
    
    <item>
      <title>流的基础和使用</title>
      <link>https://kongmu373.github.io/posts/%E6%B5%81%E7%9A%84%E5%9F%BA%E7%A1%80%E5%92%8C%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sat, 30 May 2020 16:10:15 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E6%B5%81%E7%9A%84%E5%9F%BA%E7%A1%80%E5%92%8C%E4%BD%BF%E7%94%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>函数式数据处理 流</title>
      <link>https://kongmu373.github.io/posts/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86-%E6%B5%81/</link>
      <pubDate>Sat, 30 May 2020 13:47:41 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86-%E6%B5%81/</guid>
      <description>流(Stream) 什么是流? 为什么需要流? 流的使用与流管道的构成: Stream pipeline Java中集合与流的关系 总结 1.什么是流? java.util.stream(java8 的新成员) 以声明性方式处理数据集合 有关计算的(像一个高级版本的Iterator) Stream 与 Iterator 的比较 Iterator只能显式地一个一个遍历元素，Stream只需给出对包含的元</description>
    </item>
    
    <item>
      <title>数据库详解</title>
      <link>https://kongmu373.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 30 May 2020 11:53:00 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%A6%E8%A7%A3/</guid>
      <description>数据库基本概念 什么是SQL 数据库/表 约束/索引 数据库 数据库提供结构化数据的持久化存储 索引保证数据查询的速度 事务的原子性保证数据不丢失 要么都发生,要么都不发生 数据库的基本结构 数据库的实际使用 Schema: 设计一个数据库 数据库的类型与SQL语句 整数类型： int/bigint 字符串类型:varchar(100) (变</description>
    </item>
    
    <item>
      <title>Java异常</title>
      <link>https://kongmu373.github.io/posts/Java%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Fri, 29 May 2020 19:41:08 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/Java%E5%BC%82%E5%B8%B8/</guid>
      <description>Java的异常体系 Throwable - 可以被抛出的东西(有毒) Exception - checked execption(受检异常，有毒) 预期之内的异常 IOException RuntimeException(运行时异常， 无毒) 预期之外的异常 不应该出现的 Error(错误，无毒) OutOfMemoryError 没办法处理的 catch的级联与合并 有毒(checked exception) 无毒(unche</description>
    </item>
    
    <item>
      <title>Java的IO</title>
      <link>https://kongmu373.github.io/posts/Java%E7%9A%84IO/</link>
      <pubDate>Fri, 29 May 2020 11:45:59 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/Java%E7%9A%84IO/</guid>
      <description>Java的IO IO就是输入输出 什么是IO呢？ InputStream/OutputStream IO的使用 计算机体系原理 计算机分三级 CPU 频率 3GHz -&amp;gt; 每秒30亿次（每秒运行30亿条指令 10亿换算成 1纳秒） 即1条指令大约要0.3纳秒 内存 memory 存数据 断电丢失 硬盘 (Hard Disk &amp;ndash; HDD) 固态 SSD 存数据 容量大，断电不丢失 比内存慢 文件的本质 一段字节流: 文本文件(txt</description>
    </item>
    
    <item>
      <title>Lambda实战</title>
      <link>https://kongmu373.github.io/posts/Lambda%E5%AE%9E%E6%88%98/</link>
      <pubDate>Fri, 29 May 2020 09:08:47 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/Lambda%E5%AE%9E%E6%88%98/</guid>
      <description>如何利用Lambda简化接口代码 接口实现简化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public interface OperationInterface { int operator(int a, int b); // (int a, int b) -&amp;gt; int -- (int, int) -&amp;gt;int } public class AddOperation implements OperationInterface { @Override public int operator(int a, int b) { return a+b; } } public class MultiplicationOperation implements Operatinable { @Override public int operator(int a, int b) { return a * b; } } public class OperationDemo { public static void main(String[] args) { Operatinable multiplicationOperation = new MultiplicationOperation(); System.out.println(&amp;#34;Multiplication Operation: &amp;#34; + multiplicationOperation.operator(1, 3)); Operatinable AddOperation = new AddOperation(); System.out.println(&amp;#34;AddOperation: &amp;#34;</description>
    </item>
    
    <item>
      <title>HTTP协议</title>
      <link>https://kongmu373.github.io/posts/HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Thu, 28 May 2020 14:28:21 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</guid>
      <description>HTTP协议 互联网所有东西都是基于HTTP协议 HTTP 方法 GET 和 POST 的区别 GET 所有数据全部都放在 HTTP Request header 里面 POST 真正的数据放在 HTTP Request body 里面 (登录，上传文件) DELETE PUT &amp;hellip; HTTP 状态码 2XX 成功 3XX 重定向 4XX 客户端出问题 405 客户端请求的方法被禁止 5XX HTTP状态码的博客 HTTP 请求header 重要的header Accept* Cookie User-Agent Referer 当前页面是</description>
    </item>
    
    <item>
      <title>Web前后端基础结构原理</title>
      <link>https://kongmu373.github.io/posts/Web%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84%E5%8E%9F%E7%90%86/</link>
      <pubDate>Wed, 27 May 2020 23:15:03 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/Web%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84%E5%8E%9F%E7%90%86/</guid>
      <description>计算机网络的术语 主机 每个主机会有一个地址(IPV4地址为32位，4个字节,如115.118.112.3 2^32=42亿个数字,不够用了) (网络，主机，IP地址(Internet Protocol &amp;ndash; 网络协议)) IPV6(128位，为地球的每一颗沙子分配地址) 域名与DNS 知道与哪台主机通信，即必须知</description>
    </item>
    
    <item>
      <title>Collection</title>
      <link>https://kongmu373.github.io/posts/Collection/</link>
      <pubDate>Wed, 27 May 2020 10:55:23 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/Collection/</guid>
      <description>Collection 简介 Collection是什么？(root interface) 是接口，不是类，不能被new 一组东西，一篮子鸡蛋,只包含一种元素 Collection 体系 (root interface) 例如,ArrayList的Diagrams Collection 常使用的方法: new: new ArrayList(Collection), new ArrayList() 1 2 3 4 5 6 7 8 9 10 11 12 13 Collection&amp;lt;Integer&amp;gt; c = new LinkedHashSet(); // IntegerList List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(c); // == List&amp;lt;Integer&amp;gt; list2 = new ArrayList&amp;lt;&amp;gt;(); list2.addAll(); // == List&amp;lt;Integer&amp;gt; list3 = new ArrayList&amp;lt;&amp;gt;(); for(Integer i : c) { list3.add(i);</description>
    </item>
    
    <item>
      <title>几种排序算法的实现</title>
      <link>https://kongmu373.github.io/posts/%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Wed, 27 May 2020 10:27:22 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>冒泡排序 复杂度O(n^2) 空间复杂度(1) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class BubbleSort { public static void sort(int[] array) { for (int i = 0; i &amp;lt; array.length; i++) { for (int j = 0; j &amp;lt; array.length - i - 1; j++) { if (array[i] &amp;gt; array[i + 1]) { swap(array, i, i + 1); } } } } private static void swap(int[] array, int i, int j) { int temp = array[i]; array[i] = array[j]; array[j] = temp; } } 快速排序(不是原地版本) 复杂度O(n(logn)) 空间复</description>
    </item>
    
    <item>
      <title>Lambda表达式与函数接口</title>
      <link>https://kongmu373.github.io/posts/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Tue, 26 May 2020 14:05:22 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3/</guid>
      <description>Lambda表达式与函数式接口 Lambda表达式 Lambda 是什么? 可以把Lambda表达式理解为 简洁地表示可传递匿名函数的一种方式 Lambda表达式没有名称，但它有参数列表，函数主体，返回类型，有时还可以抛出的异常列表。 有以下特性: 匿名:与匿名函数一样不需要方法名 函数:有参数列表，函数主</description>
    </item>
    
    <item>
      <title>函数式编程与Java8新特性</title>
      <link>https://kongmu373.github.io/posts/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8EJava8%E6%96%B0%E7%89%B9%E6%80%A7/</link>
      <pubDate>Tue, 26 May 2020 08:45:15 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8EJava8%E6%96%B0%E7%89%B9%E6%80%A7/</guid>
      <description>函数 就是 参数 映射成返回值. 函数式编程 &amp;ldquo;函数式编程&amp;rdquo; 是一种 &amp;ldquo;编程范式&amp;rdquo; 主要思想: 把运算过程尽量写成一系列嵌套的函数调用 -&amp;gt; y= f(g(x)) &amp;lt;=&amp;gt; y= g(x).f(). 惰性计算: 并不立刻算，只有在需要产生表达式的值才开始进行运算 函数是 &amp;ldquo;第一等公民&amp;rdquo;</description>
    </item>
    
    <item>
      <title>Java包管理</title>
      <link>https://kongmu373.github.io/posts/java%E5%8C%85%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 25 May 2020 14:29:03 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/java%E5%8C%85%E7%AE%A1%E7%90%86/</guid>
      <description>包是什么? 就是把许多类放在一起打的压缩包 什么是包管理 包管理的本质就是告诉JVM如何找到所需的第三方类库 为什么要用包管理呢？ 从运行一个JAVA程序说起： JVM的工作内容: 执行一个类的字节码 加入这个过程中碰到了新的类， 加载它 那么，去哪里加载这些类呢?(通过类路径) 类路径 (Classpath) 在哪可以找到</description>
    </item>
    
    <item>
      <title>Git常用命令</title>
      <link>https://kongmu373.github.io/posts/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 25 May 2020 14:00:44 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>git git 六行配置 git config --global user.name 你的英文名 git config --global user.email 你的邮箱 git config --global push.default simple git config --global core.quotepath false git config --global core.editor &amp;quot;code --wait&amp;quot; git config --global core.autocrlf input git 常用命令 - git config - git add 路径 - git status -sb - git commit -v - git branch x - git checkout x - git merge - git commit - git branch -d x - git log - git relog - git reset --hard XXXXX GitHub 存储代码 常用两行命令 git remote add origin git@xxxxxx git push -u origin master SSH key 验证身份 生成 SSH key 测试 SSH key 上传和下载代码 git pull /</description>
    </item>
    
    <item>
      <title>First Blood</title>
      <link>https://kongmu373.github.io/posts/first-blood/</link>
      <pubDate>Mon, 25 May 2020 10:44:19 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/first-blood/</guid>
      <description>大家好 我的博客开通了!</description>
    </item>
    
    <item>
      <title>Item8</title>
      <link>https://kongmu373.github.io/posts/effective-java/item8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kongmu373.github.io/posts/effective-java/item8/</guid>
      <description>Item 8: Avoid finalizers and cleaners（避免使用终结器和清除器） 终结器和清除器的缺点 缺点: 不能保证它们会被立即执行(不仅不能保证终结器或清洁剂能及时运行；它并不能保证它们能运行。) 在终结期间抛出的未捕获异常被忽略，该对象的终结终止。 严重影响性能。使用 try-with-resources 比终结器快得多(50倍左右,清除器比终结</description>
    </item>
    
  </channel>
</rss>