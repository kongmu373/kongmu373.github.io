<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kongmu373的博客</title>
    <link>https://kongmu373.github.io/</link>
    <description>Recent content on kongmu373的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 20 Jul 2020 19:21:40 +0800</lastBuildDate>
    
	<atom:link href="https://kongmu373.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>14</title>
      <link>https://kongmu373.github.io/posts/io/14/</link>
      <pubDate>Mon, 20 Jul 2020 19:21:40 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/io/14/</guid>
      <description>原文链接 作者：Jakob Jenkov Java OutputStream 以下是Java OutputStream类的一些 well-konwn classes: ByteArrayOutputStream FileOutputStream PipedOutputStream BufferedOutputStream FilterOutputStream DataOutputStream PrintStream ObjectOutputStream OutputStream&amp;rsquo;s and Destinations Java OutputStream通常连接到某些数据目标-如Java IO概述中所述，例如文件，网络连接，管道，内存缓冲区等 write(byte) write（byte）方法用于将单个字节写入Java OutputStream Outp</description>
    </item>
    
    <item>
      <title>13 Java InputStream</title>
      <link>https://kongmu373.github.io/posts/io/13/</link>
      <pubDate>Mon, 20 Jul 2020 19:20:43 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/io/13/</guid>
      <description>原文链接 作者：Jakob Jenkov Java InputStream Java InputStream类java.io.InputStream表示字节的有序流 InputStream Subclasses InputStream 有以下子类: ByteArrayInputStream FileInputStream PipedInputStream BufferedInputStream FilterInputStream PushbackInputStream DataInputStream ObjectInputStream SequenceInputStream InputStreams and Sources Java InputStream通常连接到某些数据源，例如文件，网络连接，管道等 Java InputStream Example 从文件读取所有字节: 1 2 3 4 5 6 7 8 9 10 11 InputStream input = new</description>
    </item>
    
    <item>
      <title>15 JavaIO: FileInputStream</title>
      <link>https://kongmu373.github.io/posts/io/15JavaIOFileInputStream/</link>
      <pubDate>Mon, 20 Jul 2020 17:47:35 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/io/15JavaIOFileInputStream/</guid>
      <description>原文链接 作者：Jakob Jenkov Java FileInputStream Java FileInputStream类java.io.FileInputStream使得可以将文件的内容读取为字节流 Java FileInputStream类是Java InputStream的子类 Java FileInputStream Example 1 2 3 4 5 6 7 8 9 10 InputStream input = new FileInputStream(&amp;#34;c:\\data\\input-text.txt&amp;#34;); int data = input.read(); while(data != -1) { //do something with data... doSomethingWithData(data); data =</description>
    </item>
    
    <item>
      <title>10-12笔记</title>
      <link>https://kongmu373.github.io/posts/io/10-12/</link>
      <pubDate>Mon, 20 Jul 2020 14:35:47 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/io/10-12/</guid>
      <description>原文链接 作者：Jakob Jenkov Java IO: Readers and Writers Java IO中的Java Reader（java.io.Reader）和Java Writer类（java.io.Writer）的工作方式与InputStream和OutputStream相似，不同之处在于Reader和Writer是基于字符的. Reader Rea</description>
    </item>
    
    <item>
      <title>7-9笔记</title>
      <link>https://kongmu373.github.io/posts/io/7-9/</link>
      <pubDate>Mon, 20 Jul 2020 13:56:51 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/io/7-9/</guid>
      <description>原文链接 作者：Jakob Jenkov Java IO: Byte &amp;amp; Char Arrays 背景：字节数组&amp;amp;字符数组是我们常用来在程序中作临时存储数据,那么我们是不是有一个已经设计好的，从`InputStream`或`Reader`的子类组件能将数据流转换到字节数组&amp;amp;字符数组的呢? Reading Arrays via InputStream or Reader ByteArrayInp</description>
    </item>
    
    <item>
      <title>JavaIONetworking笔记</title>
      <link>https://kongmu373.github.io/posts/io/JavaIONetworking%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 20 Jul 2020 13:46:28 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/io/JavaIONetworking%E7%AC%94%E8%AE%B0/</guid>
      <description>原文链接 作者: Jakob Jenkov Networking 一旦为两个进程建立网络连接，它们之间的网络通信就如同文件处理一样: 使用inputStream读取数据 使用ouputStream写入数据 即可以将文件处理的操作套用在网络连接的处理上(毕竟FileOutputStream is a subclass of OutputStream) sample 在下面的例子中process方法</description>
    </item>
    
    <item>
      <title>198 HouseRobber</title>
      <link>https://kongmu373.github.io/posts/leetcode/198-HouseRobber/</link>
      <pubDate>Mon, 20 Jul 2020 13:38:28 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/leetcode/198-HouseRobber/</guid>
      <description>对应 leetCode 198题. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package com.kongmu373.leetcode.editor.en; public class HouseRobber { public static void main(String[] args) { Solution solution = new HouseRobber().new Solution(); } /** * Recursion + Memorization * For a given house i, we have two options: * 1. Take the moeny if we didn&amp;#39;t robber house i - 1 * 2. Skip it * rob(n) = max(rob(n-2) + money[i], rob(n-1)) * Time complexity:O(n), Space complexity:O(n) * &amp;lt;p&amp;gt; * DP * &amp;lt;p&amp;gt; * dp[i]: Max money after * &amp;#34;visiting&amp;#34; house[i] * &amp;lt;p&amp;gt; * dp[i]: max(dp[i-2] + money[i],</description>
    </item>
    
    <item>
      <title>530 MiniumAbsoluteDifferentInBST</title>
      <link>https://kongmu373.github.io/posts/leetcode/530-MiniumAbsoluteDifferentInBST/</link>
      <pubDate>Mon, 20 Jul 2020 12:33:27 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/leetcode/530-MiniumAbsoluteDifferentInBST/</guid>
      <description>Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.
Example:
Input:
1 3 / 2
Output: 1
Explanation: The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).
Note:
There are at least two nodes in this BST. This question is the same as 783: https://leetcode.com/problems/minimum-dista nce-between-bst-nodes/
Related Topics Tree
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69  package com.</description>
    </item>
    
    <item>
      <title>746 MinCostClimbingStairs</title>
      <link>https://kongmu373.github.io/posts/leetcode/746-MinCostClimbingStairs/</link>
      <pubDate>Mon, 20 Jul 2020 11:09:30 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/leetcode/746-MinCostClimbingStairs/</guid>
      <description>On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 i ndexed).
Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the s tep with index 0, or the step with index 1.
Example 1:
Input: cost = [10, 15, 20] Output: 15 Explanation: Cheapest is start on cost[1], pay that cost and go to the top.
Example 2:
Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] Output: 6 Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[ 3].
Note:
cost will have a length in the range [2, 1000]. Every cost[i] will be an integer in the range [0, 999].
Related Topics Array Dynamic Programming</description>
    </item>
    
    <item>
      <title>748 ShortesCompletingWord</title>
      <link>https://kongmu373.github.io/posts/leetcode/748-ShortesCompletingWord/</link>
      <pubDate>Mon, 20 Jul 2020 10:40:42 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/leetcode/748-ShortesCompletingWord/</guid>
      <description>Find the minimum length word from a given dictionary words, which has all the letters from the string licensePlate. Such a word is said to complete the given string licensePlate
Here, for letters we ignore case. For example, &amp;ldquo;P&amp;rdquo; on the licensePlate still m atches &amp;ldquo;p&amp;rdquo; on the word.
It is guaranteed an answer exists. If there are multiple answers, return the o ne that occurs first in the array.
The license plate might have the same letter occurring multiple times. For exa mple, given a licensePlate of &amp;ldquo;PP&amp;rdquo;, the word &amp;ldquo;pair&amp;rdquo; does not complete the licens ePlate, but the word &amp;ldquo;supper&amp;rdquo; does.
Example 1:
Input: licensePlate = &amp;ldquo;1s3 PSt&amp;rdquo;, words = [&amp;ldquo;step&amp;rdquo;, &amp;ldquo;steps&amp;rdquo;, &amp;ldquo;stripe&amp;rdquo;, &amp;ldquo;stepple&amp;rdquo; ] Output: &amp;ldquo;steps&amp;rdquo; Explanation: The smallest length word that contains the letters &amp;ldquo;S&amp;rdquo;, &amp;ldquo;P&amp;rdquo;, &amp;ldquo;S&amp;rdquo;, and &amp;ldquo;T&amp;rdquo;. Note that the answer is not &amp;ldquo;step&amp;rdquo;, because the letter &amp;ldquo;s&amp;rdquo; must occur in the w ord twice.</description>
    </item>
    
    <item>
      <title>69 Sqrt</title>
      <link>https://kongmu373.github.io/posts/leetcode/69-sqrt/</link>
      <pubDate>Mon, 20 Jul 2020 08:29:35 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/leetcode/69-sqrt/</guid>
      <description>Implement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-ne gative integer. Since the return type is an integer, the decimal digits are truncated and onl y the integer part of the result is returned. Example 1: Input: 4 Output: 2 Example 2: Input: 8 Output: 2 Explanation: The square root of 8 is 2.82842&amp;hellip;, and since the decimal part is truncated, 2 is returned. Related Topics Math Binary Search 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package com.kongmu373.leetcode.editor.en; public class Sqrtx { public static void main(String[] args) {</description>
    </item>
    
    <item>
      <title>762 PrimeNumberOfSetBitsInBinaryRepresentation</title>
      <link>https://kongmu373.github.io/posts/leetcode/762-PrimeNumberOfSetBitsInBinaryRepresentation/</link>
      <pubDate>Sun, 19 Jul 2020 23:59:02 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/leetcode/762-PrimeNumberOfSetBitsInBinaryRepresentation/</guid>
      <description>Given two integers L and R, find the count of numbers in the range [L, R] (inc lusive) having a prime number of set bits in their binary representation. (Recall that the number of set bits an integer has is the number of 1s present when written in binary. For example, 21 written in binary is 10101 which has 3 set bits. Also, 1 is not a prime.) Example 1: Input: L = 6, R = 10 Output: 4 Explanation: 6 -&amp;gt; 110 (2 set bits, 2 is prime) 7 -&amp;gt; 111 (3 set bits, 3 is prime) 9 -&amp;gt; 1001 (2 set bits , 2 is prime) 10-&amp;gt;1010 (2 set bits , 2 is prime) Example 2: Input: L = 10, R = 15 Output: 5 Explanation: 10 -&amp;gt; 1010 (2 set bits, 2 is prime) 11 -&amp;gt; 1011</description>
    </item>
    
    <item>
      <title>784 LetterCasePermutation</title>
      <link>https://kongmu373.github.io/posts/leetcode/784-LetterCasePermutation/</link>
      <pubDate>Sun, 19 Jul 2020 23:37:15 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/leetcode/784-LetterCasePermutation/</guid>
      <description>Given a string S, we can transform every letter individually to be lowercase o r uppercase to create another string. Return a list of all possible strings we c ould create. Examples: Input: S = &amp;ldquo;a1b2&amp;rdquo; Output: [&amp;ldquo;a1b2&amp;rdquo;, &amp;ldquo;a1B2&amp;rdquo;, &amp;ldquo;A1b2&amp;rdquo;, &amp;ldquo;A1B2&amp;rdquo;] Input: S = &amp;ldquo;3z4&amp;rdquo; Output: [&amp;ldquo;3z4&amp;rdquo;, &amp;ldquo;3Z4&amp;rdquo;] Input: S = &amp;ldquo;12345&amp;rdquo; Output: [&amp;ldquo;12345&amp;rdquo;] Note: S will be a string with length between 1 and 12. S will consist only of letters or digits. Related Topics Backtracking Bit Manipulation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 package com.kongmu373.leetcode.editor.en; import java.util.ArrayList; import java.util.List;</description>
    </item>
    
    <item>
      <title>438 FindAllAngramsInAString</title>
      <link>https://kongmu373.github.io/posts/leetcode/438-FindAllAngramsInAString/</link>
      <pubDate>Sun, 19 Jul 2020 23:07:30 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/leetcode/438-FindAllAngramsInAString/</guid>
      <description>Given a string s and a non-empty string p, find all the start indices of p&amp;rsquo;s anagrams in s.
Strings consists of lowercase English letters only and the length of both str ings s and p will not be larger than 20,100.
The order of output does not matter.
Example 1:
Input: s: &amp;ldquo;cbaebabacd&amp;rdquo; p: &amp;ldquo;abc&amp;rdquo;
Output: [0, 6]
Explanation: The substring with start index = 0 is &amp;ldquo;cba&amp;rdquo;, which is an anagram of &amp;ldquo;abc&amp;rdquo;. The substring with start index = 6 is &amp;ldquo;bac&amp;rdquo;, which is an anagram of &amp;ldquo;abc&amp;rdquo;.
Example 2:
Input: s: &amp;ldquo;abab&amp;rdquo; p: &amp;ldquo;ab&amp;rdquo;
Output: [0, 1, 2]
Explanation: The substring with start index = 0 is &amp;ldquo;ab&amp;rdquo;, which is an anagram of &amp;ldquo;ab&amp;rdquo;. The substring with start index = 1 is &amp;ldquo;ba&amp;rdquo;, which is an anagram of &amp;ldquo;ab&amp;rdquo;. The substring with start index = 2 is &amp;ldquo;ab&amp;rdquo;, which is an anagram of &amp;ldquo;ab&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>707 DesignLinkedList</title>
      <link>https://kongmu373.github.io/posts/leetcode/707-DesignLinkedList/</link>
      <pubDate>Sun, 19 Jul 2020 22:24:59 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/leetcode/707-DesignLinkedList/</guid>
      <description>Design your implementation of the linked list. You can choose to use the singl y linked list or the doubly linked list. A node in a singly linked list should h ave two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node. If you want to use the doubly linked l ist, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed. Implement these functions in your linked list class: get(index) : Get the value of the index-th node in the linked list. If the in dex is invalid, return -1. addAtHead(val) : Add a node of value val before the first element of the link ed list. After the insertion, the new</description>
    </item>
    
    <item>
      <title>Java IO Pipes笔记</title>
      <link>https://kongmu373.github.io/posts/io/Java-IO-Pipes%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 18 Jul 2020 17:38:12 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/io/Java-IO-Pipes%E7%AC%94%E8%AE%B0/</guid>
      <description>原文链接 作者: Jakob Jenkov Creating Pipes via Java IO 通过PipedOutputStream和PipedInputStream类使用Java IO创建管道 PipedInputStream应该被连接到PipedOutputStream sample: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37</description>
    </item>
    
    <item>
      <title>Java IO Stream笔记</title>
      <link>https://kongmu373.github.io/posts/io/Stream%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 18 Jul 2020 17:18:03 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/io/Stream%E7%AC%94%E8%AE%B0/</guid>
      <description>原文链接 作者: Jakob Jenkov InputStream 类java.io.InputStream是所有Java IO输入流的基类 如果你写的组件需要从流中读数据，最好让你的组件依赖于InputStream,而不是它的子类. sample: 1 2 3 4 5 6 7 InputStream input = new FileInputStream(&amp;#34;xxxx&amp;#34;); int data = input.read(); // return a int containing the byte value of the byte read. // If there is no more data to be read, the read() method typically returns -1; while(data != -1) {</description>
    </item>
    
    <item>
      <title>Java IO Files笔记</title>
      <link>https://kongmu373.github.io/posts/io/Files/</link>
      <pubDate>Sat, 18 Jul 2020 17:06:54 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/io/Files/</guid>
      <description>原文链接 作者：Jakob Jenkov Java IO File Classes Java IO API包含以下与在Java中处理文件有关的类： File RandomAccessFile FileInputStream FileReader FileOutputStream FileWriter Reading Files via Java IO you can use FileInputStream or FileReader to read a file 这两个类：要么一个字节一个字节读，或者一个数组去读 你需要按照文件的顺序去读 如果你需要跳读，你可以使用RandomAccessFile Writing Files via Java IO you can use a FileOutputStream or</description>
    </item>
    
    <item>
      <title>Java IO Overview笔记</title>
      <link>https://kongmu373.github.io/posts/io/io-overview/</link>
      <pubDate>Sat, 18 Jul 2020 16:31:40 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/io/io-overview/</guid>
      <description>原文链接 作者: Jakob Jenkov 输入与输出 - Source and Destination Java IO package 主要用于从source读取raw data,或者写一些raw data到一个destination. 其中source与 destination 主要有以下这些: Files Pipes Network Connections In-memory Buffers(e.g. arrays) System.in,out,error stream 流 stream是连续无限的数据流 能够从stream中读，或写数据 一个stream是连接于</description>
    </item>
    
    <item>
      <title>190 ReverseBits</title>
      <link>https://kongmu373.github.io/posts/leetcode/190-ReverseBits/</link>
      <pubDate>Sat, 18 Jul 2020 15:57:12 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/leetcode/190-ReverseBits/</guid>
      <description>Reverse bits of a given 32 bits unsigned integer. Example 1: Input: 00000010100101000001111010011100 Output: 00111001011110000010100101000000 Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000. Example 2: Input: 11111111111111111111111111111101 Output: 10111111111111111111111111111111 Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111. Note: Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2&amp;rsquo;s complement notation. Therefore, in Example 2 above the input represents the signed integer -3 and the output</description>
    </item>
    
    <item>
      <title>13 RomantoInteger</title>
      <link>https://kongmu373.github.io/posts/leetcode/13-RomantoInteger/</link>
      <pubDate>Sat, 18 Jul 2020 15:18:38 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/leetcode/13-RomantoInteger/</guid>
      <description>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one&amp;rsquo;s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V</description>
    </item>
    
    <item>
      <title>108 ConvertSortedArraytoBinarySearchTree</title>
      <link>https://kongmu373.github.io/posts/leetcode/108-ConvertSortedArraytoBinarySearchTree/</link>
      <pubDate>Sat, 18 Jul 2020 14:51:38 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/leetcode/108-ConvertSortedArraytoBinarySearchTree/</guid>
      <description>Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted array: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following he ight balanced BST: 0 / \ -3 9 / / -10 5 Related Topics Tree Depth-first Search 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60</description>
    </item>
    
    <item>
      <title>1475 FinalPricesWithASpecialDiscountInAShop</title>
      <link>https://kongmu373.github.io/posts/leetcode/1475-FinalPricesWithASpecialDiscountInAShop/</link>
      <pubDate>Sat, 18 Jul 2020 14:47:14 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/leetcode/1475-FinalPricesWithASpecialDiscountInAShop/</guid>
      <description>Given the array prices where prices[i] is the price of the ith item in a shop. There is a special discount for items in the shop, if you buy the ith item, the n you will receive a discount equivalent to prices[j] where j is the minimum ind ex such that j &amp;gt; i and prices[j] &amp;lt;= prices[i], otherwise, you will not receive a ny discount at all. Return an array where the ith element is the final price you will pay for the ith item of the shop considering the special discount. Example 1: Input: prices = [8,4,6,2,3] Output: [4,2,4,2,3] Explanation: For item 0 with price[0]=8 you will receive a discount equivalent to prices[1] =4, therefore, the final price you will pay is 8 - 4 = 4. For item 1 with price[1]=4 you will receive a discount equivalent</description>
    </item>
    
    <item>
      <title>代码质量插件</title>
      <link>https://kongmu373.github.io/posts/%E9%A1%B9%E7%9B%AE/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E6%8F%92%E4%BB%B6/</link>
      <pubDate>Fri, 17 Jul 2020 14:06:04 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E9%A1%B9%E7%9B%AE/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E6%8F%92%E4%BB%B6/</guid>
      <description>Checkstyle插件 https://checkstyle.sourceforge.io/ https://maven.apache.org/plugins/maven-checkstyle-plugin/usage.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 &amp;lt;!-- checkstyle --&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-checkstyle-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.1.1&amp;lt;/version&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;configLocation&amp;gt;checkstyle.xml&amp;lt;/configLocation&amp;gt; &amp;lt;encoding&amp;gt;utf-8&amp;lt;/encoding&amp;gt; &amp;lt;consoleOutput&amp;gt;true&amp;lt;/consoleOutput&amp;gt; &amp;lt;failsOnError&amp;gt;true&amp;lt;/failsOnError&amp;gt; &amp;lt;linkXRef&amp;gt;false&amp;lt;/linkXRef&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;executions&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;id&amp;gt;validate&amp;lt;/id&amp;gt; &amp;lt;phase&amp;gt;validate&amp;lt;/phase&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt;check&amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;/executions&amp;gt; &amp;lt;/plugin&amp;gt; + checkstyle_checks.xml &amp;lt;property name=&amp;quot;severity&amp;quot; value=&amp;quot;error&amp;quot;/&amp;gt; &amp;lt;property name=&amp;quot;fileExtensions&amp;quot; value=&amp;quot;java, properties, xml&amp;quot;/&amp;gt; &amp;lt;!-- Excludes all &#39;module-info.java&#39; files --&amp;gt; &amp;lt;!-- See https://checkstyle.org/config_filefilters.html --&amp;gt; &amp;lt;module name=&amp;quot;BeforeExecutionExclusionFileFilter&amp;quot;&amp;gt; &amp;lt;property name=&amp;quot;fileNamePattern&amp;quot; value=&amp;quot;module\-info\.java$&amp;quot;/&amp;gt; &amp;lt;/module&amp;gt; &amp;lt;!-- https://checkstyle.org/config_filters.html#SuppressionFilter --&amp;gt; &amp;lt;module name=&amp;quot;SuppressionFilter&amp;quot;&amp;gt; &amp;lt;property name=&amp;quot;file&amp;quot; value=&amp;quot;${org.checkstyle.google.suppressionfilter.config}&amp;quot; default=&amp;quot;checkstyle-suppressions.xml&amp;quot; /&amp;gt; &amp;lt;property name=&amp;quot;optional&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt; &amp;lt;/module&amp;gt; &amp;lt;!-- Checks for whitespace --&amp;gt; &amp;lt;!-- See http://checkstyle.org/config_whitespace.html --&amp;gt; &amp;lt;module name=&amp;quot;FileTabCharacter&amp;quot;&amp;gt; &amp;lt;property name=&amp;quot;eachLine&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt; &amp;lt;/module&amp;gt; &amp;lt;module name=&amp;quot;LineLength&amp;quot;&amp;gt; &amp;lt;property name=&amp;quot;fileExtensions&amp;quot; value=&amp;quot;java&amp;quot;/&amp;gt; &amp;lt;property name=&amp;quot;max&amp;quot; value=&amp;quot;120&amp;quot;/&amp;gt; &amp;lt;property name=&amp;quot;ignorePattern&amp;quot; value=&amp;quot;^package.* | ^import.*|a href|href|http://|https://|ftp://&amp;quot;/&amp;gt; &amp;lt;/module&amp;gt; &amp;lt;module name=&amp;quot;NewlineAtEndOfFile&amp;quot;/&amp;gt; &amp;lt;module name=&amp;quot;RegexpSingleline&amp;quot;&amp;gt; &amp;lt;property name=&amp;quot;format&amp;quot; value=&amp;quot;\s+$&amp;quot;/&amp;gt; &amp;lt;property</description>
    </item>
    
    <item>
      <title>单元测试</title>
      <link>https://kongmu373.github.io/posts/%E9%A1%B9%E7%9B%AE/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Thu, 16 Jul 2020 16:55:41 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E9%A1%B9%E7%9B%AE/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid>
      <description>为啥要用单元测试 不用手工测试,节省测试时间 防止回归 新的改动不会改变原有或其他的功能 提高代码质量 保证行为正确性 写好一个单元测试 快速: 花非常少的时间来运行单元测试 独立: 可以单独运行，不依赖其他文件 可重复: 多次运行单元测试返回一致的结果 自检查: 不用人工检查 关于测试用例命名 测试的名称应包</description>
    </item>
    
    <item>
      <title>JVM</title>
      <link>https://kongmu373.github.io/posts/%E9%9D%A2%E8%AF%95%E9%A2%98/JVM/</link>
      <pubDate>Thu, 16 Jul 2020 09:27:10 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E9%9D%A2%E8%AF%95%E9%A2%98/JVM/</guid>
      <description>JLS 与 JVMS Java Language Specification(Java语言规范) 定义Java语言的语法 (Java编译器) (Java Virtual Machine Specification)Java虚拟机规范 定义字节码如何在JVM中执行 两个没有必然联系(JLS是*.java 编译成 *.class的规范, JVMS是*.class在JVM中运行</description>
    </item>
    
    <item>
      <title>API接口设计</title>
      <link>https://kongmu373.github.io/posts/%E9%A1%B9%E7%9B%AE/API%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</link>
      <pubDate>Wed, 15 Jul 2020 16:54:08 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E9%A1%B9%E7%9B%AE/API%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</guid>
      <description>API接口设计 REST: Representational State Transfer 表述性状态转移 Microsoft REST API Guidelines URL结构 REST API 不出现动词 url都是对资源的描述(描述应该易于理解) 最好带版本控制信息 例子:api.kongmu373.com/v1/users/1 支持的方法 方法 描述 幂等性 GET 返回一个对象的当前值 True PUT 替换一个对象，或者创建命名对象(如果适用</description>
    </item>
    
    <item>
      <title>Docker连接数据库以及SpringBoot与Mybatis的集成</title>
      <link>https://kongmu373.github.io/posts/%E9%A1%B9%E7%9B%AE/docker%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Wed, 15 Jul 2020 13:30:15 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E9%A1%B9%E7%9B%AE/docker%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>开始连接数据库 mysql安装 下载镜像文件 docker pull mysql:5.7 创建实例并启动 1 2 3 4 5 6 7 # window10 我在Docker Desktop 将D盘设置为挂载文件夹 docker run -p 3306:3306 --name mysql \ -v D:/tmp/mysql/log:/var/log/mysql \ -v D:/tmp/mysql/data:/var/lib/mysql \ -v D:/tmp/mysql/conf:/etc/mysql \ -e MYSQL_ROOT_PASSWORD=123 \ -d mysql:5.7 参数说明 -p 3306:3306: 将容器的3306端口映射到主机的3306端口 -v D:/tmp/mysql/log:/var/log/mysql</description>
    </item>
    
    <item>
      <title>项目结构与数据模型转换</title>
      <link>https://kongmu373.github.io/posts/%E9%A1%B9%E7%9B%AE/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Wed, 15 Jul 2020 08:40:34 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E9%A1%B9%E7%9B%AE/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid>
      <description>项目结构 config 创建一个个Bean 放在这里 @Configuration/@Bean controller 对外暴露API接口 注意的点 Controller不要有过多的处理逻辑 参数校验越早做越好 @RestController/@Controller/@RequestMapping @RequestBody/@ResponseBody @PathVarible/@RequestParam manager/service 跨模块调用或模块内的调用 要先写接口, 再写实现类，可以少走点坑.(如 UserInfoManager UserInfoMagerImpl) @Component/@Service dao 还是写接口，再写实现类 @Repository dao/mapper external 调用别的服务与业务有关系的，如: 云服务，red</description>
    </item>
    
    <item>
      <title>自动化构建</title>
      <link>https://kongmu373.github.io/posts/java/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA/</link>
      <pubDate>Tue, 14 Jul 2020 10:23:49 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/java/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA/</guid>
      <description>为什么需要自动化构建? 假设只能使用手工构建，我们要做的步骤: git checkout 编译代码 手工运行测试 执行打包命令 拷贝到(多台)服务器上 避免单点故障 更新的时候服务不中断 负载均衡 手工杀掉旧java进程,启动新进程 自动化构建带来的好处 减少出错的可能 减少重复劳动 提高工作效率 持续集成(Continuous</description>
    </item>
    
    <item>
      <title>Spring Boot 开发</title>
      <link>https://kongmu373.github.io/posts/spring/spring-boot-%E5%BC%80%E5%8F%91/</link>
      <pubDate>Tue, 14 Jul 2020 10:18:27 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/spring/spring-boot-%E5%BC%80%E5%8F%91/</guid>
      <description>Spring boot 开发四大步 添加相应依赖 添加相应注解 编写代码 添加相应配置</description>
    </item>
    
    <item>
      <title>Git Commit Message</title>
      <link>https://kongmu373.github.io/posts/git/git-commit-message/</link>
      <pubDate>Tue, 14 Jul 2020 09:17:31 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/git/git-commit-message/</guid>
      <description>格式 &amp;lt;类型&amp;gt;(&amp;lt;范围&amp;gt;) : &amp;lt;主题&amp;gt; &amp;lt;可选 内容&amp;gt; 如:开发完成用户管理模块 feat(manager): implement of the user manager to complete user rleated operation. 1. xxx 2. xxx 3. xxx 类型 feat: (新特性给功能模块，不是新的构建脚本) fix: (修复功能模块的bug,不是修复构建脚本的bug) refactor: (重构生产代码, 重命名一个变量</description>
    </item>
    
    <item>
      <title>自动化测试</title>
      <link>https://kongmu373.github.io/posts/java/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Mon, 13 Jul 2020 14:04:50 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/java/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</guid>
      <description>互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuous integration，简称CI），其中自动化测试也是尤为重要. 自动化测试 什么是自动化测试 一段程序代码，不提供具体的程序功能，只保证主要程序功能符合预期 后勤保证 编写需要(很高的)成本</description>
    </item>
    
    <item>
      <title>操作系统于计算机原理</title>
      <link>https://kongmu373.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 13 Jul 2020 08:47:04 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/</guid>
      <description>计算机体系原理 CPU,寄存器,内存与汇编指令 CPU:相当于人的大脑，通过执行来自内存的指令，来控制整个电脑稳定的运行。 寄存器：临时存储,进行数据的存储，就是你的口袋 内存: 也是进行数据的存储，但是比寄存器要慢，就是你的背包 汇编指令: 是助记符，因为人要自己去记机器码实在太伤了，所以用</description>
    </item>
    
    <item>
      <title>Spring</title>
      <link>https://kongmu373.github.io/posts/%E9%9D%A2%E8%AF%95%E9%A2%98/spring/</link>
      <pubDate>Wed, 08 Jul 2020 17:09:31 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E9%9D%A2%E8%AF%95%E9%A2%98/spring/</guid>
      <description>什么是IoC容器， 为什么需要IoC 背景:一个应用要启动，可能有不同的组件,把不同职责的功能放在不同的类里面，类之间互相依赖,随着应用规模越来越大，这种依赖就越来越繁杂 IoC,Inverse of Control(控制反转) 不需要手动控制各种对象的创建和依赖,(由IoC容器完成)将依赖的装配权交给IoC容器</description>
    </item>
    
    <item>
      <title>类型与反射</title>
      <link>https://kongmu373.github.io/posts/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Tue, 07 Jul 2020 16:30:41 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%8F%8D%E5%B0%84/</guid>
      <description>什么是反射(Reflection)? 运行时行为，动态调用 动态代理 一般来说,JVM中创建每一个对象都需要一份说明书,创建多少个对象这份说明书是不会变的 我们把这份说明书称为class对象 class对象是由 xx.java源代码 通过 javac 编译成的(如果maven，.class文件放在targ</description>
    </item>
    
    <item>
      <title>Web</title>
      <link>https://kongmu373.github.io/posts/%E9%9D%A2%E8%AF%95%E9%A2%98/web/</link>
      <pubDate>Tue, 07 Jul 2020 14:54:54 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E9%9D%A2%E8%AF%95%E9%A2%98/web/</guid>
      <description>常见的HTTP状态码 2XX 一切正常 3XX 代表跳转 4XX 代表客户端异常 5XX 代表服务端异常 常用状态码 200/201 created / 301 永久/ 302 临时 403/403 , 500/502/503/504 get/post的区别? get获取资源，而post用于发送数据 get参数在请求字符串里，post参数放在request body中 GET: 只有header POST: 把数据放在body get</description>
    </item>
    
    <item>
      <title>基本数据结构和算法</title>
      <link>https://kongmu373.github.io/posts/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 06 Jul 2020 14:34:29 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</guid>
      <description>集合类中常见的数据结构以及时间复杂度 ArrayList: 数组, 随机查找是常数 寻址O(1) 插入/删除 O(n) 有序的话，二分查找是O(logn) LinkedList: 双链表,可当作队列和栈 寻址O(n) 插入/删除 O(1) 查找O(n) HashSet/HashMap: 哈希表 都是O(1) TreeSet/TreeMap: 红黑树 都是O(lgn) ConcurrentHashMap: 分段+哈希表 LinkedHashMap:链表+哈希表 队列和</description>
    </item>
    
    <item>
      <title>计算机网络</title>
      <link>https://kongmu373.github.io/posts/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Mon, 06 Jul 2020 14:02:41 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</guid>
      <description>TCP/UDP 区别 TCP, Transmission control Protocol 稳定可靠，有纠错和重传 保证交付 应用对质量要求高的场景 UDP, User Datagram Protocol 快，质量低 尽最大可能交付 对质量要求不高的场景，如:直播 在浏览器中发起一个HTTP请求，底层都是TCP连接 TCP三次握手和四次挥手 从浏览器发出请求到服务器接收到请求发送了什么? 在浏览器输入https://ta</description>
    </item>
    
    <item>
      <title>计算机体系原理</title>
      <link>https://kongmu373.github.io/posts/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 06 Jul 2020 10:30:12 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E5%8E%9F%E7%90%86/</guid>
      <description>hardware(CPU, 硬盘，内存) -&amp;gt; OS -&amp;gt; software 进程和线程的区别? 进程和线程都是操作系统层面的概念 os-&amp;gt; process(进程,拥有独立的内存空间以及文件描述符(FD,File Descriptor),是一个基本的程序单元,进程之间是互相独立的) 进程中所有的线程共享一块内存以及文件描述符等各类进程内的资源 共享资源</description>
    </item>
    
    <item>
      <title>Redis</title>
      <link>https://kongmu373.github.io/posts/java/redis/</link>
      <pubDate>Sun, 05 Jul 2020 09:53:34 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/java/redis/</guid>
      <description>分布式与redis 当服务器不止一台的时候，就不能将会话状态信息放在服务器的内存里了 用redis集中存储状态信息，就可以在分布式中维持登录状态信息. Redis为什么这么快? redis相当于一个HashMap 运行在内存中(因为运行在内存中相对于MySQL就很贵了) IO多路复用机制 单线</description>
    </item>
    
    <item>
      <title>Java的异常体系</title>
      <link>https://kongmu373.github.io/posts/%E9%9D%A2%E8%AF%95%E9%A2%98/Java%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/</link>
      <pubDate>Sun, 05 Jul 2020 09:50:22 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E9%9D%A2%E8%AF%95%E9%A2%98/Java%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/</guid>
      <description>Java的异常体系结构? Throwable，异常/错误的祖先类,任何可以被丢出来的东西 throws Throwable的子类 Error extends Throwable 致命的错误 Exception extends Throwable 可以从异常状态中恢复 RuntimeException extends Exception 预料之外的异常,通常代表一个bug unchecked Exception 不用被编译器所检查,其他异常都需要编译器检查(checkedException) 常</description>
    </item>
    
    <item>
      <title>集合框架</title>
      <link>https://kongmu373.github.io/posts/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Sat, 04 Jul 2020 19:11:14 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</guid>
      <description>HashMap原理 详情在另一篇博客HashMap源码分析 List/Set/Map 区别 List 有位置顺序，因此可以通过下标获取对应的值,get(index) 存储有顺序的东西 Set 无序的 元素不同 当我们需要去重的时候，就可以使用它 Map 映射 HashMap和HashTable的区别? HashTable基本不用 相同点: 都是基</description>
    </item>
    
    <item>
      <title>Java面向对象</title>
      <link>https://kongmu373.github.io/posts/%E9%9D%A2%E8%AF%95%E9%A2%98/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Sat, 04 Jul 2020 18:26:46 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E9%9D%A2%E8%AF%95%E9%A2%98/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
      <description>==/equals有什么区别? == 是判断是否为同一个对象 equals 是判断两个对象是否相等 深拷贝/浅拷贝有什么区别? 拷贝一个引用对象： 浅拷贝：拷贝该对象，但并不把该对象里面的引用链所有对象全部拷贝一份，只是把引用地址复制一份 深拷贝: 拷贝对象的时候，把该对象里面的引用链的对象都复制一份而不是单</description>
    </item>
    
    <item>
      <title>Java基础</title>
      <link>https://kongmu373.github.io/posts/%E9%9D%A2%E8%AF%95%E9%A2%98/java%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Fri, 03 Jul 2020 16:28:56 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E9%9D%A2%E8%AF%95%E9%A2%98/java%E5%9F%BA%E7%A1%80/</guid>
      <description>Java程序的运行原理 当点击编译器的运行按钮后，发生了什么呢?(分为编译过程和启动过程) .java文件执行编译(被Compiler的编译器处理)，生成.calss文件(字节码) .class文件被jvm识别和加载 即成链状: .java -(编译)-&amp;gt; .class -(被识别)-&amp;gt; jvm 编译后的代码</description>
    </item>
    
    <item>
      <title>Stream-常见使用</title>
      <link>https://kongmu373.github.io/posts/java/stream-%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Thu, 02 Jul 2020 16:00:20 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/java/stream-%E5%9F%BA%E7%A1%80/</guid>
      <description>本文章主要介绍了Stream使用的常见方法以及Java样例代码. 常见使用 筛选过滤 filter方法 接受一个判定(Predicate),并返回一个符合判定的元素流 1 2 3 List&amp;lt;Car&amp;gt; carList = store.stream() .filter(Car::isElectric) .collect(toList()); distinct方法 返回一个没有重复的元素流(用元素的equals方法来判断) 1 2 3 4 List&amp;lt;Integer&amp;gt; number = Arrays.asList(1, 2, 3, 3, 5, 5);</description>
    </item>
    
    <item>
      <title>微店项目部署</title>
      <link>https://kongmu373.github.io/posts/spring/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Wed, 01 Jul 2020 08:21:49 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/spring/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/</guid>
      <description>本文章主要将一个微信小商店的后端部署到服务器上的步骤过程记录下来，方便以后的部署。 项目地址:https://github.com/kongmu373/wxshop 以及前端地址: https://github.com/kongmu373/westore-react-1 步骤 在阿里云上买一台ECS服务器 部署模型 服务器对外暴露一个nginx(80port), 所有外部连接都经</description>
    </item>
    
    <item>
      <title>TCP与socket 2</title>
      <link>https://kongmu373.github.io/posts/java/TCP%E4%B8%8Esocket-2/</link>
      <pubDate>Sat, 27 Jun 2020 20:32:29 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/java/TCP%E4%B8%8Esocket-2/</guid>
      <description>Socket server与client传输数据 传输数据的例子(html或者js) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public static void main(String[] args) throws Exception { int port = 8080; ServerSocket socket = new ServerSocket(); socket.bind(new InetSocketAddress(&amp;#34;127.0.0.1&amp;#34;, port)); while (true) { Socket from = socket.accept(); BufferedReader reader = new BufferedReader(new InputStreamReader(from.getInputStream())); String line; List&amp;lt;String&amp;gt; headers = new ArrayList&amp;lt;&amp;gt;(); while (!(line = reader.readLine()).isEmpty()) { System.out.println(line); headers.add(line); } String firstLine = headers.get(0); String[] s = firstLine.split(&amp;#34; &amp;#34;); System.out.println(s[1]); from.getOutputStream().write(&amp;#34;HTTP/1.1 200 OK\r\n&amp;#34;.getBytes()); if (s[1].endsWith(&amp;#34;.js&amp;#34;)) {</description>
    </item>
    
    <item>
      <title>微服务</title>
      <link>https://kongmu373.github.io/posts/java/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Wed, 24 Jun 2020 08:24:50 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/java/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</guid>
      <description>什么是微服务 传统开发与微服务的对比图 传统大应用的缺点 难以扩展 scale(水平扩展) &amp;laquo;淘宝技术这十年&amp;raquo; 交付时间长，开发慢 (焦油坑) &amp;laquo;人月神话&amp;raquo; 复杂，维护困难 故障率高 微服务 整个应用按照业务拆分，互相使用RPC/HTTP/REST通信 松散</description>
    </item>
    
    <item>
      <title>日志系统</title>
      <link>https://kongmu373.github.io/posts/java/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Tue, 23 Jun 2020 09:12:04 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/java/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</guid>
      <description>日志系统 为什么需要日志系统? 查找bug,就需要看日志 线上服务器出bug，重点查看就是日志 sping中log如何工作? app -&amp;gt; slf4j (运行时，动态完成与一系列日志框架的绑定(包括log4j logback jul)) slf4j(simple log facade for java) 并非一个日志框架，只是一个门面 设计模式 facade java的包中没有层级关系,但是logger是由</description>
    </item>
    
    <item>
      <title>TCP与socket</title>
      <link>https://kongmu373.github.io/posts/java/TCP%E4%B8%8Esocket/</link>
      <pubDate>Mon, 22 Jun 2020 20:29:53 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/java/TCP%E4%B8%8Esocket/</guid>
      <description>通信协议没有100%可靠的 经典的红军/蓝军问题 红军 - 敌人 - 蓝军 红军与蓝军交换信息都要经过敌人 因此无论怎么发，都没有100%可靠的通信协议 计算机网络与传统电信网络 传统电信网络 (电话网络) 电路交换网路 (震动-电信号) 计算机网络 目标:实现全球的连接，并且物理无法毁坏的网络 分组交换(在不</description>
    </item>
    
    <item>
      <title>Item16</title>
      <link>https://kongmu373.github.io/posts/effective-java/item16/</link>
      <pubDate>Sun, 21 Jun 2020 08:41:51 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/effective-java/item16/</guid>
      <description>Item 16: In public classes, use accessor methods, not public fields（在公共类中，使用访问器方法，而不是公共字段） 退化类 1 2 3 4 5 // Degenerate classes like this should not be public! class Point { public double x; public double y; } 不好的地方: 由于此类的数据字段是直接访问的，因此这些类没有提供封装的好处 不能在不更改API的情况下更改表示形式 在访问或者设置字段的时候不能使用额外的</description>
    </item>
    
    <item>
      <title>Item15</title>
      <link>https://kongmu373.github.io/posts/effective-java/item15/</link>
      <pubDate>Sat, 20 Jun 2020 17:10:08 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/effective-java/item15/</guid>
      <description>Item 13: Minimize the accessibility of classes and members(尽量减少类和成员的可访问性) 封装 封装的概念： 一个经过精心设计的模块将隐藏其所有实现细节，从而将其API与实现完全分开 然后，模块仅通过其API进行通信，而忽略了彼此的内部工作原理 为什么使用封装: 它使构成系统的模块脱钩，从而使它们可以独立开发，测试，优</description>
    </item>
    
    <item>
      <title>Item14</title>
      <link>https://kongmu373.github.io/posts/effective-java/item14/</link>
      <pubDate>Fri, 19 Jun 2020 14:56:53 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/effective-java/item14/</guid>
      <description>Item 14: Consider implementing Comparable（考虑实现 Comparable 接口） Comparable实现的例子 Single-field Comparable with object reference field 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public final class CaseInsensitiveString implements Comparable&amp;lt;CaseInsensitiveString&amp;gt; { private final String s; public CaseInsensitiveString(String s) { this.s = Objects.requiredNonNull() } ... public int compareTo(CaseInsensitiveString cis) { return String.CASE_INSENSITIVE_ORDER.compare(s, cis); } public static void main(String[] args) { Set&amp;lt;CaseInsensitiveString&amp;gt; s = new TreeSet&amp;lt;&amp;gt;(); for (String arg : args) { s.add(new CaseInsensitiveString(arg)); } System.out.println(s); } } Multiple-field Comparable with object reference field 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18</description>
    </item>
    
    <item>
      <title>Spring原理</title>
      <link>https://kongmu373.github.io/posts/spring/spring%E5%8E%9F%E7%90%86/</link>
      <pubDate>Thu, 18 Jun 2020 16:41:11 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/spring/spring%E5%8E%9F%E7%90%86/</guid>
      <description>为什么需要Spring呢？ 开发一个应用要把它分成很多个模块 模块之间用约定进行通信 模块分成很多个子模块 如果是java应用程序，那么模块可以理解为一个个对象(Object,在Spring中命名为Bean) 模块之间存在相互依赖,如：当A模块必须使用B模块才能完成A模块提供的服务(A依赖</description>
    </item>
    
    <item>
      <title>Item13</title>
      <link>https://kongmu373.github.io/posts/effective-java/item13/</link>
      <pubDate>Thu, 18 Jun 2020 16:13:31 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/effective-java/item13/</guid>
      <description>Item 13: Override clone judiciously（谨慎覆盖 clone 方法） Cloneable接口 跟Serializable接口一样，只是声明该对象可以被克隆，具体行为由类设计者决定。 如果一个类实现了Cloneable，Object的clone方法就返回该对象的拷贝，否则就会抛出CloneNotSuppor</description>
    </item>
    
    <item>
      <title>Docker</title>
      <link>https://kongmu373.github.io/posts/java/docker/</link>
      <pubDate>Wed, 17 Jun 2020 13:59:25 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/java/docker/</guid>
      <description>Docker能做什么? 保证开发，测试，交付，部署的环境完全一致 保证资源的隔离 启动临时的，用完即弃的环境，例如测试 迅速 (秒级)超大规模和扩容 Docker 与 Virtual Machines 相比 Docker的基本概念 镜像 imgage 一个预先定义好的模板文件， Docker引擎可以按照这个摸板文件启动无数个一模一样，互不干扰的容器 容器 container</description>
    </item>
    
    <item>
      <title>Java正则表达式</title>
      <link>https://kongmu373.github.io/posts/java/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Tue, 16 Jun 2020 14:18:27 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/java/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>常用的元字符 元字符 描述 ^ 开始位置 $ 结束位置 . 单个任意字符(不一定包含换行符) \w 单个&amp;quot;word&amp;quot;字符 字母/数字/下划线/汉字 \s 单个空白字符 (\r\n\t) \d 单个数字字符 \b 单词的开始或结束 用到它们的原来的意思的时候，需要转义 (?s).* . 包括匹配换行符 重复 重复字符 描述 * 0次或多次 + 1次或</description>
    </item>
    
    <item>
      <title>动态代理与AOP</title>
      <link>https://kongmu373.github.io/posts/java/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8EAOP/</link>
      <pubDate>Mon, 15 Jun 2020 16:08:15 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/java/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8EAOP/</guid>
      <description>什么是AOP Aspect-Oriented Programming 面向切面编程 相对于OOP (面向对象编程) AOP是面向切面编程，关注一个统一的切面 AOP和Spring是不同的东西 AOP适合于哪些场景 需要统一处理的场景 日志 缓存 鉴权 如果用OOP来做需要怎么办? 装饰器模式 装饰器模式 Decorator pattern 动态地为一个对象增加功能，但是不改变其结构 本质上是</description>
    </item>
    
    <item>
      <title>Item11 12</title>
      <link>https://kongmu373.github.io/posts/effective-java/item11-12/</link>
      <pubDate>Sun, 14 Jun 2020 18:47:20 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/effective-java/item11-12/</guid>
      <description>Item 11: Always override hashCode when you override equals（当覆盖 equals 时，始终覆盖 hashCode） equals相同的，hascodes也必须相同· equals不相同的，hashcodes也可以相同 没有hashCode的实现将破坏基于hash实现的集合的功能 不好的hashCode实现会降低基于hash实现的性能</description>
    </item>
    
    <item>
      <title>Item10</title>
      <link>https://kongmu373.github.io/posts/effective-java/item10/</link>
      <pubDate>Sun, 14 Jun 2020 17:21:00 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/effective-java/item10/</guid>
      <description>Item 10: Obey the general contract when overriding equals（覆盖 equals 方法时应遵守的约定） 覆盖 equals 方法似乎很简单，但是有很多覆盖的方式会导致出错，而且后果可能非常严重。 equals 约定 &amp;ndash; equivalence relation 覆盖equals 应该遵守(equivalence relation) 自反性(Reflexive), x.equals(x) == true 对称性(Symmetric), x.equals(y) == y.equals(x) 传递性(Tra</description>
    </item>
    
    <item>
      <title>Item9</title>
      <link>https://kongmu373.github.io/posts/effective-java/item9/</link>
      <pubDate>Sun, 14 Jun 2020 14:35:29 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/effective-java/item9/</guid>
      <description>Item 9: Prefer try-with-resources to try-finally（使用 try-with-resources 优于 try-finally） try-finally 从历史上看，try-finally 语句是确保正确关闭资源的最佳方法 1 2 3 4 5 6 7 8 9 // try-finally - No longer the best way to close resources! static String firstLineOfFile(String path) throws IOException { BufferedReader br = new BufferedReader(new FileReader(path)); try { return br.readLine(); } finally { br.close(); } } 但添加第二个资源时，情况会变得更糟： 1 2 3 4 5 6 7 8 9 10 11</description>
    </item>
    
    <item>
      <title>浅析SpringWeb应用</title>
      <link>https://kongmu373.github.io/posts/java/%E6%B5%85%E6%9E%90SpringWeb%E5%BA%94%E7%94%A8/</link>
      <pubDate>Sun, 14 Jun 2020 09:51:00 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/java/%E6%B5%85%E6%9E%90SpringWeb%E5%BA%94%E7%94%A8/</guid>
      <description>Web应用 处理HTTP请求 从HTTP请求中提取query string(查询字符串) 从HTTP请求中接收payload(负载)中的参数 返回HTTP响应 status code HTTP resonse header HTTP response body JSON HTML &amp;hellip; HTTP GET Query string ?param1=value1&amp;amp;param2=value2 通常用来传递非敏感信息 使用@RequestParam进行接收 RESTful API 使用HTTP动词来代表动作 GET: 获取资源</description>
    </item>
    
    <item>
      <title>浅析URL</title>
      <link>https://kongmu373.github.io/posts/html/%E6%B5%85%E6%9E%90URL/</link>
      <pubDate>Sun, 14 Jun 2020 08:30:32 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/html/%E6%B5%85%E6%9E%90URL/</guid>
      <description>WWW = URL + HTTP + HTML，本篇主要讲的是URL URL举例: https://www.baidu.com:443/s?wd=hi&amp;amp;rsv_spt=1#5 https 协议 www.baidu.com 域名(ip) :443 https的端口 /s 路径 ?wd=hi&amp;amp;rsv_spt=1 查询参数 #5 锚点 什么是IP Internet Protocal 约定了两件事: 如何定位一台设备 如何封装数据报文，以跟其他设备交流 几个特殊的IP 127.0.0.1表示自己 localhost通过hosts文件指定为自己</description>
    </item>
    
    <item>
      <title>Html常用标签</title>
      <link>https://kongmu373.github.io/posts/html/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Sat, 13 Jun 2020 14:03:41 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/html/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</guid>
      <description>a 标签 a标签的两个属性： href (hyper ref 超引用或者超链接) 可以选择的取值 网址(跳转到别人的页面上) https://google.com http://google.com //google.com (继承当前的协议) 路径(在自己http服务进行跳转) /a/b/c 以及 a/b/c 开启http服务之后，(&amp;quot;/&amp;quot;)根目录就不再是硬盘的根目录 (&amp;quot;/&amp;quot;)根目录的位置在于你</description>
    </item>
    
    <item>
      <title>Item7</title>
      <link>https://kongmu373.github.io/posts/effective-java/item7/</link>
      <pubDate>Fri, 12 Jun 2020 19:30:16 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/effective-java/item7/</guid>
      <description>Item7: Eliminate obsolete object references （排除过时的对象引用） 自实现的栈可能存在忽略的内存泄露 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 mport java.util.Arrays; import java.util.EmptyStackException; // Can you spot the &amp;#34;memory leak&amp;#34;? public class Stack { private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(Object e) { ensureCapacity(); elements[size++] = e; } public Object pop() { if (size == 0) throw new EmptyStackException(); return elements[--size]; } /** * Ensure space for at least one more element, roughly * doubling</description>
    </item>
    
    <item>
      <title>Item6</title>
      <link>https://kongmu373.github.io/posts/effective-java/item6/</link>
      <pubDate>Fri, 12 Jun 2020 16:27:48 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/effective-java/item6/</guid>
      <description>Item6 Avoid creating unecessary objects(避免创建不必要的对象) 重用对象从而提高性能 exmaple1: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // Reusing expensive object for improved performance (Pages 22 and 23) public class RomanNumerals { // Performance can be greatly improved! (Page 22) static boolean isRomanNumeralSlow(String s) { return s.matches(&amp;#34;^(?=.)M*(C[MD]|D?C{0,3})&amp;#34; + &amp;#34;(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$&amp;#34;); } // Reusing expensive object for improved performance (Page 23) private static final Pattern ROMAN = Pattern.compile( &amp;#34;^(?=.)M*(C[MD]|D?C{0,3})&amp;#34; + &amp;#34;(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$&amp;#34;); static boolean isRomanNumeralFast(String s) { return ROMAN.matcher(s).matches(); } public static void main(String[] args) { int numSets = Integer.parseInt(args[0]);</description>
    </item>
    
    <item>
      <title>Item4 5</title>
      <link>https://kongmu373.github.io/posts/effective-java/item4-5/</link>
      <pubDate>Fri, 12 Jun 2020 16:01:33 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/effective-java/item4-5/</guid>
      <description>Item4 Enforce noninstantiability with a private constructor(强迫非实例化的类使用私有构造方法) 1 2 3 4 5 6 7 8 9 // Noninstantiable utility class public class UtilityClass { // Suppress(禁用) default constructor for noninstantiability. private UtilityClass() { throw new AssertionError(); } // Remainder omitted } 总结 使用私有构造方法避免实例化该类 如果调用该私有方法就抛出异常 这种技术在构建工具类的时候，经常会被用到 Item5 Prefer dependency injection to hardwiring resources (依</description>
    </item>
    
    <item>
      <title>Spring</title>
      <link>https://kongmu373.github.io/posts/Spring/</link>
      <pubDate>Fri, 12 Jun 2020 08:57:48 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/Spring/</guid>
      <description>Spring是什么? Java世界应用的事实标准 Spring容器 - 一个 IoC容器 Spring MVC - 基于Spring和Servlet的Web应用框架 Spring Boot - 集成度和自动化程序更高 没有Spring,我们会怎么做呢? 选择一: 一个main程序打天下 非常轻量，适用于非常简单的场景 一旦规模上来之后 难以维护 是</description>
    </item>
    
    <item>
      <title>Java的注解</title>
      <link>https://kongmu373.github.io/posts/java/Java%E7%9A%84%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Wed, 10 Jun 2020 16:21:49 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/java/Java%E7%9A%84%E6%B3%A8%E8%A7%A3/</guid>
      <description>什么是注解? Class是什么？ Class是Java类的说明书 你或者JVM阅读该说明书，创建类的实例 注解就是说明书中的一小段信息/文本/标记 Annotation 可以携带参数 可以在运行时被阅读 注解怎么写? 新建一个类选择注解 元注解 @Rentention 保留,RetentionPolicy 默认CLASS 2 @Target ElementType @Documented @Inherited @Repeatable 注解的属性</description>
    </item>
    
    <item>
      <title>Item3</title>
      <link>https://kongmu373.github.io/posts/effective-java/item3/</link>
      <pubDate>Wed, 10 Jun 2020 16:16:08 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/effective-java/item3/</guid>
      <description>Item 3:Enforce the singleton property with a private consturctor or an enum type 使用私有构造函数或枚举类型实施单例属性 Singleton with public final field (使用final字段实现单例) 不好使用单元测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Elvis { public static final Elvis INSTANCE = new Elvis(); private Elvis() {} public void leaveTheBuiding() { // do something } // This code would normally appear outside the class! public static void main(String[] args) { Elvis elvis = Elvis.INSTANCE; elvis.leaveTheBuilding(); } } Single with static factory 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16</description>
    </item>
    
    <item>
      <title>Item2</title>
      <link>https://kongmu373.github.io/posts/effective-java/item2/</link>
      <pubDate>Wed, 10 Jun 2020 15:45:39 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/effective-java/item2/</guid>
      <description>Item 2: Consider a builder when faced with many constructor parameters. 都构造函数有多个参数时，考虑用builder. 当类的参数过多的时候,使用不同方法创建对象对应的情况 构造函数 过于啰嗦 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // Telescoping constructor pattern - does not scale well! public class NutritionFacts { private final int servingSize; // (mL) required private final int servings; // (per container) required private final int calories; // (per serving) optional private final</description>
    </item>
    
    <item>
      <title>Item1</title>
      <link>https://kongmu373.github.io/posts/effective-java/item1/</link>
      <pubDate>Wed, 10 Jun 2020 15:42:17 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/effective-java/item1/</guid>
      <description>Item1: 考虑以静态工厂方法代替构造函数 什么是静态工厂方法 它是一个类提供的公共静态工厂方法，作用只是一个返回类实例的静态方法。 例子 1 2 3 4 // boolean 基本类型 转换为 Boolean 对象的引用 public static Boolean valueOf(boolean b) { return b ? Boolean.TRUE : Boolean.FALSE; } 注意的是静态工厂方法与来设计模式的工厂方法模式不同. 静态工厂方法的优缺点 相较于构造函数的优点:</description>
    </item>
    
    <item>
      <title>Java的泛型</title>
      <link>https://kongmu373.github.io/posts/Java%E7%9A%84%E6%B3%9B%E5%9E%8B/</link>
      <pubDate>Tue, 09 Jun 2020 18:53:43 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/Java%E7%9A%84%E6%B3%9B%E5%9E%8B/</guid>
      <description>为什么需要泛型? 其实, 以前是没有泛型的 没有泛型写起来就很啰嗦,不同的类型要写出很多除了类型都相同的代码 有了泛型就可以用省力的方法编写类型安全的代码 List&amp;lt;String&amp;gt; Map&amp;lt;String, Object&amp;gt; Map&amp;lt;String, List&amp;lt;Object&amp;gt;&amp;gt; 泛型存在的问题 向后兼容性 https://www.zhihu.com/question/28665443 只有两条路: type erasue(擦除) -&amp;gt; Java的选择 搞一套全新的API -&amp;gt; C#的选择 Java选择擦除带</description>
    </item>
    
    <item>
      <title>类型与反射</title>
      <link>https://kongmu373.github.io/posts/%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Tue, 09 Jun 2020 11:19:47 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%8D%E5%B0%84/</guid>
      <description>Spring全家桶，任何上规模的框架,都使用了框架 Java的类与Class RTTI(Run-Time Type Identification) 运行时类型识别 将子类赋值给父类,调用子类的方法报错 1 2 Object obj = new WhiteCat(); obj.catchMouse(); // catchMouse()是猫的方法，Object类没有这个方法，所以编译报错 Object.getClass 实体方法拿到类型信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17</description>
    </item>
    
    <item>
      <title>字符串原理</title>
      <link>https://kongmu373.github.io/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 08 Jun 2020 16:57:36 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%9F%E7%90%86/</guid>
      <description>字符串是最重要的引用类型 互联网基本上只干一件事: 处理字符串 能处理好字符串是Web服务器的基本要求 字符串的不可变性 字符串的不可变是如何保证的? String是final class不能被继承 保存字符的数组是final的，不能改变指向 String的所有公开API都不能改变这个value的</description>
    </item>
    
    <item>
      <title>HashMap源码分析</title>
      <link>https://kongmu373.github.io/posts/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 08 Jun 2020 10:09:46 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>常见面试问题 HashMap默认容量? HashMap如何扩容? HashMap的数组大小为什么一定要是2的幂? HashMap为什么是线程不安全的 Java 7到8做了哪些改进? 为什么? &amp;hellip; 哈希表的简介 核心是基于哈希值的桶和链表 将一个元素映射成一个便于搜索的哈希值 O(1)的平均查找,插入 删除时间 桶</description>
    </item>
    
    <item>
      <title>基础算法与数据结构</title>
      <link>https://kongmu373.github.io/posts/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 08 Jun 2020 08:14:31 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>程序=算法+数据结构 (程序如何执行 + 怎么存储数据) 为什么我们需要算法和数据结构呢？ 计算机世界的基石， 是程序员的内功 对代码效率的提升是本质的 面试需要&amp;hellip; 算法的复杂度 时间复杂度 O(1) - 哈希桶/数组随机寻址 (常数) 和问题的规模无关 O(n) - 遍历 (线性) 在数组中找某个元素 解决问题的时间</description>
    </item>
    
    <item>
      <title>Stream</title>
      <link>https://kongmu373.github.io/posts/stream/</link>
      <pubDate>Sun, 07 Jun 2020 14:33:15 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/stream/</guid>
      <description>什么是Stream 一个 &amp;ldquo;流&amp;rdquo; 好处: 不容易出错 简化代码 可读性/可维护性++ // 请把姓张的用户挑出来，把他们按照年龄排序,然后把它们的名单报告给我 List&amp;lt;User&amp;gt; users = getUsers(); List&amp;lt;String&amp;gt; list = users.stream(). filter(user -&amp;gt; user.name.startsWith(&amp;quot;张&amp;quot;)) .sorted((Comparator.comparing(User::getAge))) .map(User::getName) .collect(Collectors.toList()); 使用idea的pl</description>
    </item>
    
    <item>
      <title>进阶算法</title>
      <link>https://kongmu373.github.io/posts/%E6%A1%B6%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Tue, 02 Jun 2020 20:33:41 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E6%A1%B6%E6%8E%92%E5%BA%8F/</guid>
      <description>面试算法题套路 沟通和交流 得到算法题 沟通理解题意 给出暴力解(不动脑子的解法) 分析问题，沟通 给出正常的算法解题 优化(剪枝) 动态规划 找出状态转移方程 上台阶问题 有一楼梯共m级，若每次只能跨上一级或二级，要走上第m级,共有多少走法? f(m) = f(m-1) + f(m-2) 硬币问题</description>
    </item>
    
    <item>
      <title>线程池</title>
      <link>https://kongmu373.github.io/posts/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link>
      <pubDate>Tue, 02 Jun 2020 08:28:19 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid>
      <description>线程池与Callable/Future 什么是线程池 线程时昂贵的 (Java线程模型的缺陷) 线程池时预先定义好的若干个线程 Java中的线程池 不用频繁创建线程 Callable/Future 类比Runnable, Callable可以返回值，抛出异常 Future代表一个&amp;quot;未来才会返回的结果&amp;rdquo; 实战</description>
    </item>
    
    <item>
      <title>生产者与消费者模型</title>
      <link>https://kongmu373.github.io/posts/%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jun 2020 19:09:43 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</guid>
      <description>使用三种方法解决生产者与消费者模型 wait/notify/notifyAll Lock/Condition(JUC) BlockingQueue(JUC) wait/notify/notifyAll 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 public class Main { public static void main(String[] args) throws InterruptedException { final Object lock = new Object(); Optional&amp;lt;Integer&amp;gt; empty = Optional.empty(); Container container = new Container(empty); Producer producer = new Producer(container, lock); Consumer consumer = new Consumer(container, lock);</description>
    </item>
    
    <item>
      <title>多线程带来的问题</title>
      <link>https://kongmu373.github.io/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 01 Jun 2020 13:41:41 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>线程不安全的表现 数据错误 i++问题 死锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // 死锁代码 public class Main { private static final Object lock1 = new Object(); private static final Object lock2 = new Object(); public static void main(String[] args) throws InterruptedException { new Thread1().start(); new Thread2().start(); } private static class Thread1 extends Thread { @Override public void run() { synchronized (lock1) { try { Thread.sleep(500); } catch (InterruptedException ignored) { } synchronized (lock2) { System.out.println(); } } } } private static class Thread2 extends</description>
    </item>
    
    <item>
      <title>多线程基本原理</title>
      <link>https://kongmu373.github.io/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jun 2020 10:41:18 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description>为什么需要多线程? Thread线程 Java中线程的表示 多线程问题的来源 多线程的应用场景 一、为什么需要多线程? Java的执行模型是同步/阻塞的 如果你执行非常耗时的操作，当前方法的执行流会阻塞，等待耗时的操作执行完 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // main方法要打印&amp;#34;main&amp;#</description>
    </item>
    
    <item>
      <title>流的基础和使用</title>
      <link>https://kongmu373.github.io/posts/%E6%B5%81%E7%9A%84%E5%9F%BA%E7%A1%80%E5%92%8C%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sat, 30 May 2020 16:10:15 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E6%B5%81%E7%9A%84%E5%9F%BA%E7%A1%80%E5%92%8C%E4%BD%BF%E7%94%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>函数式数据处理 流</title>
      <link>https://kongmu373.github.io/posts/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86-%E6%B5%81/</link>
      <pubDate>Sat, 30 May 2020 13:47:41 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86-%E6%B5%81/</guid>
      <description>流(Stream) 什么是流? 为什么需要流? 流的使用与流管道的构成: Stream pipeline Java中集合与流的关系 总结 1.什么是流? java.util.stream(java8 的新成员) 以声明性方式处理数据集合 有关计算的(像一个高级版本的Iterator) Stream 与 Iterator 的比较 Iterator只能显式地一个一个遍历元素，Stream只需给出对包含的元</description>
    </item>
    
    <item>
      <title>数据库详解</title>
      <link>https://kongmu373.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 30 May 2020 11:53:00 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%A6%E8%A7%A3/</guid>
      <description>数据库基本概念 什么是SQL 数据库/表 约束/索引 数据库 数据库提供结构化数据的持久化存储 索引保证数据查询的速度 事务的原子性保证数据不丢失 要么都发生,要么都不发生 数据库的基本结构 数据库的实际使用 Schema: 设计一个数据库 数据库的类型与SQL语句 整数类型： int/bigint 字符串类型:varchar(100) (变</description>
    </item>
    
    <item>
      <title>Java异常</title>
      <link>https://kongmu373.github.io/posts/Java%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Fri, 29 May 2020 19:41:08 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/Java%E5%BC%82%E5%B8%B8/</guid>
      <description>Java的异常体系 Throwable - 可以被抛出的东西(有毒) Exception - checked execption(受检异常，有毒) 预期之内的异常 IOException RuntimeException(运行时异常， 无毒) 预期之外的异常 不应该出现的 Error(错误，无毒) OutOfMemoryError 没办法处理的 catch的级联与合并 有毒(checked exception) 无毒(unche</description>
    </item>
    
    <item>
      <title>Java的IO</title>
      <link>https://kongmu373.github.io/posts/Java%E7%9A%84IO/</link>
      <pubDate>Fri, 29 May 2020 11:45:59 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/Java%E7%9A%84IO/</guid>
      <description>Java的IO IO就是输入输出 什么是IO呢？ InputStream/OutputStream IO的使用 计算机体系原理 计算机分三级 CPU 频率 3GHz -&amp;gt; 每秒30亿次（每秒运行30亿条指令 10亿换算成 1纳秒） 即1条指令大约要0.3纳秒 内存 memory 存数据 断电丢失 硬盘 (Hard Disk &amp;ndash; HDD) 固态 SSD 存数据 容量大，断电不丢失 比内存慢 文件的本质 一段字节流: 文本文件(txt</description>
    </item>
    
    <item>
      <title>Lambda实战</title>
      <link>https://kongmu373.github.io/posts/Lambda%E5%AE%9E%E6%88%98/</link>
      <pubDate>Fri, 29 May 2020 09:08:47 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/Lambda%E5%AE%9E%E6%88%98/</guid>
      <description>如何利用Lambda简化接口代码 接口实现简化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public interface OperationInterface { int operator(int a, int b); // (int a, int b) -&amp;gt; int -- (int, int) -&amp;gt;int } public class AddOperation implements OperationInterface { @Override public int operator(int a, int b) { return a+b; } } public class MultiplicationOperation implements Operatinable { @Override public int operator(int a, int b) { return a * b; } } public class OperationDemo { public static void main(String[] args) { Operatinable multiplicationOperation = new MultiplicationOperation(); System.out.println(&amp;#34;Multiplication Operation: &amp;#34; + multiplicationOperation.operator(1, 3)); Operatinable AddOperation = new AddOperation(); System.out.println(&amp;#34;AddOperation: &amp;#34;</description>
    </item>
    
    <item>
      <title>HTTP协议</title>
      <link>https://kongmu373.github.io/posts/HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Thu, 28 May 2020 14:28:21 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</guid>
      <description>HTTP协议 互联网所有东西都是基于HTTP协议 HTTP 方法 GET 和 POST 的区别 GET 所有数据全部都放在 HTTP Request header 里面 POST 真正的数据放在 HTTP Request body 里面 (登录，上传文件) DELETE PUT &amp;hellip; HTTP 状态码 2XX 成功 3XX 重定向 4XX 客户端出问题 405 客户端请求的方法被禁止 5XX HTTP状态码的博客 HTTP 请求header 重要的header Accept* Cookie User-Agent Referer 当前页面是</description>
    </item>
    
    <item>
      <title>Web前后端基础结构原理</title>
      <link>https://kongmu373.github.io/posts/Web%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84%E5%8E%9F%E7%90%86/</link>
      <pubDate>Wed, 27 May 2020 23:15:03 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/Web%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84%E5%8E%9F%E7%90%86/</guid>
      <description>计算机网络的术语 主机 每个主机会有一个地址(IPV4地址为32位，4个字节,如115.118.112.3 2^32=42亿个数字,不够用了) (网络，主机，IP地址(Internet Protocol &amp;ndash; 网络协议)) IPV6(128位，为地球的每一颗沙子分配地址) 域名与DNS 知道与哪台主机通信，即必须知</description>
    </item>
    
    <item>
      <title>Collection</title>
      <link>https://kongmu373.github.io/posts/Collection/</link>
      <pubDate>Wed, 27 May 2020 10:55:23 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/Collection/</guid>
      <description>Collection 简介 Collection是什么？(root interface) 是接口，不是类，不能被new 一组东西，一篮子鸡蛋,只包含一种元素 Collection 体系 (root interface) 例如,ArrayList的Diagrams Collection 常使用的方法: new: new ArrayList(Collection), new ArrayList() 1 2 3 4 5 6 7 8 9 10 11 12 13 Collection&amp;lt;Integer&amp;gt; c = new LinkedHashSet(); // IntegerList List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(c); // == List&amp;lt;Integer&amp;gt; list2 = new ArrayList&amp;lt;&amp;gt;(); list2.addAll(); // == List&amp;lt;Integer&amp;gt; list3 = new ArrayList&amp;lt;&amp;gt;(); for(Integer i : c) { list3.add(i);</description>
    </item>
    
    <item>
      <title>几种排序算法的实现</title>
      <link>https://kongmu373.github.io/posts/%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Wed, 27 May 2020 10:27:22 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>冒泡排序 复杂度O(n^2) 空间复杂度(1) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class BubbleSort { public static void sort(int[] array) { for (int i = 0; i &amp;lt; array.length; i++) { for (int j = 0; j &amp;lt; array.length - i - 1; j++) { if (array[i] &amp;gt; array[i + 1]) { swap(array, i, i + 1); } } } } private static void swap(int[] array, int i, int j) { int temp = array[i]; array[i] = array[j]; array[j] = temp; } } 快速排序(不是原地版本) 复杂度O(n(logn)) 空间复</description>
    </item>
    
    <item>
      <title>Lambda表达式与函数接口</title>
      <link>https://kongmu373.github.io/posts/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Tue, 26 May 2020 14:05:22 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3/</guid>
      <description>Lambda表达式与函数式接口 Lambda表达式 Lambda 是什么? 可以把Lambda表达式理解为 简洁地表示可传递匿名函数的一种方式 Lambda表达式没有名称，但它有参数列表，函数主体，返回类型，有时还可以抛出的异常列表。 有以下特性: 匿名:与匿名函数一样不需要方法名 函数:有参数列表，函数主</description>
    </item>
    
    <item>
      <title>函数式编程与Java8新特性</title>
      <link>https://kongmu373.github.io/posts/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8EJava8%E6%96%B0%E7%89%B9%E6%80%A7/</link>
      <pubDate>Tue, 26 May 2020 08:45:15 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8EJava8%E6%96%B0%E7%89%B9%E6%80%A7/</guid>
      <description>函数 就是 参数 映射成返回值. 函数式编程 &amp;ldquo;函数式编程&amp;rdquo; 是一种 &amp;ldquo;编程范式&amp;rdquo; 主要思想: 把运算过程尽量写成一系列嵌套的函数调用 -&amp;gt; y= f(g(x)) &amp;lt;=&amp;gt; y= g(x).f(). 惰性计算: 并不立刻算，只有在需要产生表达式的值才开始进行运算 函数是 &amp;ldquo;第一等公民&amp;rdquo;</description>
    </item>
    
    <item>
      <title>Java包管理</title>
      <link>https://kongmu373.github.io/posts/java%E5%8C%85%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 25 May 2020 14:29:03 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/java%E5%8C%85%E7%AE%A1%E7%90%86/</guid>
      <description>包是什么? 就是把许多类放在一起打的压缩包 什么是包管理 包管理的本质就是告诉JVM如何找到所需的第三方类库 为什么要用包管理呢？ 从运行一个JAVA程序说起： JVM的工作内容: 执行一个类的字节码 加入这个过程中碰到了新的类， 加载它 那么，去哪里加载这些类呢?(通过类路径) 类路径 (Classpath) 在哪可以找到</description>
    </item>
    
    <item>
      <title>Git常用命令</title>
      <link>https://kongmu373.github.io/posts/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 25 May 2020 14:00:44 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>git git 六行配置 git config --global user.name 你的英文名 git config --global user.email 你的邮箱 git config --global push.default simple git config --global core.quotepath false git config --global core.editor &amp;quot;code --wait&amp;quot; git config --global core.autocrlf input git 常用命令 - git config - git add 路径 - git status -sb - git commit -v - git branch x - git checkout x - git merge - git commit - git branch -d x - git log - git relog - git reset --hard XXXXX GitHub 存储代码 常用两行命令 git remote add origin git@xxxxxx git push -u origin master SSH key 验证身份 生成 SSH key 测试 SSH key 上传和下载代码 git pull /</description>
    </item>
    
    <item>
      <title>First Blood</title>
      <link>https://kongmu373.github.io/posts/first-blood/</link>
      <pubDate>Mon, 25 May 2020 10:44:19 +0800</pubDate>
      
      <guid>https://kongmu373.github.io/posts/first-blood/</guid>
      <description>大家好 我的博客开通了!</description>
    </item>
    
    <item>
      <title>Item8</title>
      <link>https://kongmu373.github.io/posts/effective-java/item8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://kongmu373.github.io/posts/effective-java/item8/</guid>
      <description>Item 8: Avoid finalizers and cleaners（避免使用终结器和清除器） 终结器和清除器的缺点 缺点: 不能保证它们会被立即执行(不仅不能保证终结器或清洁剂能及时运行；它并不能保证它们能运行。) 在终结期间抛出的未捕获异常被忽略，该对象的终结终止。 严重影响性能。使用 try-with-resources 比终结器快得多(50倍左右,清除器比终结</description>
    </item>
    
  </channel>
</rss>